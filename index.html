<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Audio Reactive Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #drop-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            border: 2px dashed #444;
            box-sizing: border-box;
            transition: background-color 0.3s, border-color 0.3s, opacity 0.5s;
            z-index: 10;
            opacity: 1;
        }
        #drop-zone.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #drop-zone.dragover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: #fff;
        }
        #drop-zone p {
            font-size: 1.5rem;
            pointer-events: none; /* Make text non-interactive */
        }
        #audio-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            display: none; /* Hidden by default */
        }
        audio {
            width: 300px;
        }

        /* --- Simplified Hamburger Menu & Sidebar --- */
        #menu-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: rgba(0,0,0,0.7);
            border: 1px solid #555;
            color: white;
            padding: 12px;
            cursor: pointer;
            border-radius: 8px;
            width: 48px;
            height: 48px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            transition: all 0.3s ease;
        }
        
        /* Camera Angle Panel */
        #camera-angle-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: rgba(0, 0, 0, 0);
            border: none;
            color: #fff;
            padding: 8px;
            cursor: pointer;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        #camera-angle-toggle:hover {
            background: rgba(0,0,0,0.8);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        #camera-angle-toggle.active {
            background: rgba(0, 170, 255, 0.3);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 170, 255, 0.3);
        }
        

        
        #camera-angle-panel {
            position: absolute;
            top: 70px;
            right: 20px;
            width: 400px;
            height: 500px;
            background: transparent;
            border: none;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            backdrop-filter: none;
            box-shadow: none;
            overflow: visible;
            min-width: 300px;
            min-height: 300px;
        }
        #camera-angle-panel.open {
            display: block;
        }
        
        #camera-angle-panel::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            background: linear-gradient(-45deg, transparent 30%, #555 30%, #555 40%, transparent 40%);
            cursor: se-resize;
        }
        
        .camera-view {
            position: absolute;
            width: 180px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-radius: 6px;
            overflow: hidden;
            min-width: 120px;
            min-height: 80px;
            z-index: 1001;
        }
        
        .camera-view:nth-child(1) {
            top: 10px;
            right: 10px;
        }
        
        .camera-view:nth-child(2) {
            top: 140px;
            right: 10px;
        }
        
        .camera-view:nth-child(3) {
            top: 270px;
            right: 10px;
        }
        
        .camera-view canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .camera-view-label {
            position: absolute;
            top: 5px;
            left: 5px;
            color: #fff;
            font-size: 10px;
            background: rgba(0,0,0,0.5);
            padding: 2px 6px;
            border-radius: 3px;
            pointer-events: none;
            z-index: 1002;
        }
        
        .camera-view-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: rgba(0,0,0,0.3);
            cursor: move;
            z-index: 1002;
        }
        
        .camera-view-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            background: linear-gradient(-45deg, transparent 30%, #555 30%, #555 40%, transparent 40%);
            cursor: se-resize;
            z-index: 1002;
        }
        

        

        #menu-toggle:hover {
            background: rgba(0,0,0,0.9);
            border-color: #777;
        }
        #menu-toggle .bar {
            width: 100%;
            height: 3px;
            background: white;
            transition: all 0.3s ease-in-out;
            border-radius: 2px;
        }
        #menu-toggle.open .bar1 {
            transform: rotate(45deg) translate(6px, 7px);
        }
        #menu-toggle.open .bar2 {
            opacity: 0;
        }
        #menu-toggle.open .bar3 {
            transform: rotate(-45deg) translate(6px, -7px);
        }

        #controls-panel {
            position: absolute;
            top: 0;
            left: -350px; /* Hidden by default */
            width: 330px;
            height: 100%;
            background: rgba(15, 15, 15, 0.95);
            z-index: 1000;
            padding: 80px 15px 15px 15px;
            box-shadow: 2px 0 15px rgba(0,0,0,0.7);
            transition: left 0.3s ease-in-out;
            overflow-y: auto;
            box-sizing: border-box;
            backdrop-filter: blur(10px);
        }
        #controls-panel.open {
            left: 0;
        }
        
        /* File Management Section */
        .file-section {
            background: rgba(30, 30, 30, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }
        .file-section h3 {
            margin: 0 0 15px 0;
            color: #0af;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-section h3::before {
            content: "üìÅ";
            font-size: 1.2em;
        }
        .file-list {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 10px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 2px 0;
            background: rgba(50, 50, 50, 0.5);
            border-radius: 4px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .file-item:hover {
            background: rgba(70, 70, 70, 0.7);
        }
        .file-item.active {
            background: rgba(0, 170, 255, 0.3);
            border: 1px solid #0af;
        }
        .file-item .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .file-item .file-remove {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.7em;
            cursor: pointer;
            margin-left: 8px;
        }
        .file-item .file-remove:hover {
            background: #ff6666;
        }
        .file-upload-btn {
            width: 100%;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        .file-upload-btn:hover {
            background: #444;
            border-color: #666;
        }
        
        .control-group {
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }
        .control-group:last-child {
            border-bottom: none;
        }
        .control-group h3 {
            margin-top: 0;
            color: #0af;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .control-group h3::before {
            font-size: 1.1em;
        }
        .control-group:nth-child(2) h3::before { content: "üéµ"; }
        .control-group:nth-child(3) h3::before { content: "üí°"; }
        .control-group:nth-child(4) h3::before { content: "üî¶"; }
        .control-group:nth-child(5) h3::before { content: "‚òÄÔ∏è"; }
        .control-group:nth-child(6) h3::before { content: "‚ú®"; }
        .control-group:nth-child(7) h3::before { content: "üåä"; }
        .control-group:nth-child(8) h3::before { content: "‚ö°"; }
        .control-group:nth-child(9) h3::before { content: "üåä"; }
        .control-group:nth-child(10) h3::before { content: "üí•"; }
        .control-group:nth-child(11) h3::before { content: "üéÆ"; }
        .control-group:nth-child(12) h3::before { content: "‚å®Ô∏è"; }
        .control-group:nth-child(13) h3::before { content: "üìπ"; }
        
        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
        }
        .control-group input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            padding: 0;
            background: none;
            cursor: pointer;
            border-radius: 4px;
        }
        .control-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        .control-group select, .control-group button {
            width: 100%;
            padding: 6px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }
        .control-group select:hover, .control-group button:hover {
            background: #444;
            border-color: #666;
        }

        /* Code View Panel */
        #code-view-toggle {
            position: absolute;
            top: 70px;
            right: 20px;
            z-index: 1001;
            background: rgba(0,0,0,0.7);
            border: none;
            color: #fff;
            padding: 8px;
            cursor: pointer;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        #code-view-toggle:hover {
            background: rgba(0,0,0,0.8);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        #code-view-toggle.active {
            background: rgba(0, 255, 170, 0.3);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 255, 170, 0.3);
        }
        
        #code-view-panel {
            position: absolute;
            top: 120px;
            right: 20px;
            width: 450px;
            height: 400px;
            background: rgba(15, 15, 15, 0.3);
            border: 1px solid rgba(0, 255, 170, 0.3);
            border-radius: 12px;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 170, 0.1);
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            animation: codePanelGlow 3s ease-in-out infinite alternate;
        }
        
        #code-view-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(0, 255, 170, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 255, 170, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 40% 60%, rgba(0, 255, 170, 0.08) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        @keyframes codePanelGlow {
            0% {
                box-shadow: 0 8px 32px rgba(0, 255, 170, 0.1);
                border-color: rgba(0, 255, 170, 0.3);
            }
            100% {
                box-shadow: 0 8px 32px rgba(0, 255, 170, 0.2);
                border-color: rgba(0, 255, 170, 0.5);
            }
        }
        
        @keyframes codeLineAppear {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes livePulse {
            0%, 100% {
                opacity: 0.7;
                color: #00ffaa;
            }
            50% {
                opacity: 1;
                color: #00ffff;
            }
        }
        
        .live-indicator {
            animation: livePulse 2s ease-in-out infinite;
        }
        #code-view-panel.open {
            display: block;
        }
        
        #code-view-panel::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            background: linear-gradient(-45deg, transparent 30%, #555 30%, #555 40%, transparent 40%);
            cursor: se-resize;
        }
        
        .code-view-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 35px;
            background: linear-gradient(90deg, rgba(0, 255, 170, 0.2), rgba(0, 255, 170, 0.1));
            cursor: move;
            z-index: 1002;
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-size: 13px;
            color: #00ffaa;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 170, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .code-view-content {
            position: absolute;
            top: 35px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(30, 30, 30, 0.2);
            overflow: hidden;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.5;
            color: #d4d4d4;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }
        
        .code-view-line {
            margin: 3px 0;
            white-space: pre-wrap;
            word-break: break-all;
            padding: 3px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .code-view-line::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(0, 255, 170, 0.3);
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }
        
        .code-view-line.active {
            background: linear-gradient(90deg, rgba(0, 255, 170, 0.15), rgba(0, 255, 170, 0.05));
            color: #00ffaa;
            border-left: 3px solid #00ffaa;
            padding-left: 12px;
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0, 255, 170, 0.1);
        }
        
        .code-view-line.active::before {
            transform: scaleY(1);
        }
        
        .code-view-line:hover {
            background: rgba(0, 255, 170, 0.1);
            transform: translateX(2px);
        }
        
        .code-view-line.function {
            color: #569cd6;
            text-shadow: 0 0 5px rgba(86, 156, 214, 0.3);
        }
        
        .code-view-line.comment {
            color: #6a9955;
            font-style: italic;
        }
        
        .code-view-line.string {
            color: #ce9178;
            text-shadow: 0 0 3px rgba(206, 145, 120, 0.3);
        }
        
        .code-view-line.number {
            color: #b5cea8;
            font-weight: bold;
        }
        
        .code-view-line.keyword {
            color: #c586c0;
            text-shadow: 0 0 4px rgba(197, 134, 192, 0.3);
        }
        
        .code-view-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            background: linear-gradient(-45deg, transparent 30%, #555 30%, #555 40%, transparent 40%);
            cursor: se-resize;
            z-index: 1002;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Menu Toggle Button -->
    <div id="menu-toggle">
        <div class="bar bar1"></div>
        <div class="bar bar2"></div>
        <div class="bar bar3"></div>
    </div>

    <!-- Camera Angle Toggle Button -->
    <div id="camera-angle-toggle">üì∑</div>

    <!-- Camera Angle Panel -->
    <div id="camera-angle-panel">
        <div class="camera-view" data-view="top">
            <div class="camera-view-header"></div>
            <canvas id="camera-top"></canvas>
            <div class="camera-view-label">Top</div>
            <div class="camera-view-resize-handle"></div>
        </div>
        <div class="camera-view" data-view="front">
            <div class="camera-view-header"></div>
            <canvas id="camera-front"></canvas>
            <div class="camera-view-label">Front</div>
            <div class="camera-view-resize-handle"></div>
        </div>
        <div class="camera-view" data-view="perspective">
            <div class="camera-view-header"></div>
            <canvas id="camera-perspective"></canvas>
            <div class="camera-view-label">Perspective</div>
            <div class="camera-view-resize-handle"></div>
        </div>
    </div>

    <!-- Code View Toggle Button -->
    <div id="code-view-toggle">üíª</div>

    <!-- Code View Panel -->
    <div id="code-view-panel">
        <div class="code-view-header">
            <span style="margin-right: 8px;">üíª</span>
            Code Execution Monitor
            <span class="live-indicator" style="margin-left: auto; font-size: 10px;">LIVE</span>
        </div>
        <div class="code-view-content" id="code-view-content">
            <div class="code-view-line comment">// Audio-reactive visualizer code execution...</div>
            <div class="code-view-line">Waiting for audio input...</div>
        </div>
        <div class="code-view-resize-handle"></div>
    </div>

    <!-- Controls Sidebar -->
    <div id="controls-panel">
        <!-- File Management Section -->
        <div class="file-section">
            <h3>3D Models</h3>
            <div id="model-list" class="file-list">
                <div class="file-item" style="color: #888; font-style: italic;">No models loaded</div>
            </div>
            <input type="file" id="model-upload" accept=".glb,.gltf" multiple style="display: none;">
            <button class="file-upload-btn" onclick="document.getElementById('model-upload').click()">Add 3D Models</button>
        </div>
        
        <div class="file-section">
            <h3>Audio Files</h3>
            <div id="audio-list" class="file-list">
                <div class="file-item" style="color: #888; font-style: italic;">No audio files loaded</div>
            </div>
            <input type="file" id="audio-upload" accept=".mp3,.wav,.ogg" multiple style="display: none;">
            <button class="file-upload-btn" onclick="document.getElementById('audio-upload').click()">Add Audio Files</button>
        </div>
        <div class="control-group">
            <h3>Bass Light</h3>
            <label for="bass-intensity">Intensity</label>
            <input type="range" id="bass-intensity" min="0" max="10" step="0.1" value="5">
            <label for="bass-color">Color</label>
            <input type="color" id="bass-color" value="#ff0000">
        </div>
        <div class="control-group">
            <h3>Treble Light</h3>
            <label for="treble-intensity">Intensity</label>
            <input type="range" id="treble-intensity" min="0" max="10" step="0.1" value="3">
            <label for="treble-color">Color</label>
            <input type="color" id="treble-color" value="#0000ff">
        </div>
        <div class="control-group">
            <h3>Lasers</h3>
            <label for="laser-opacity">Opacity</label>
            <input type="range" id="laser-opacity" min="0" max="1" step="0.01" value="0.7">
        </div>
        <div class="control-group">
            <h3>Bloom Effect</h3>
            <label for="bloom-strength">Strength</label>
            <input type="range" id="bloom-strength" min="0" max="3" step="0.1" value="1.2">
            <label for="bloom-threshold">Threshold</label>
            <input type="range" id="bloom-threshold" min="0" max="1" step="0.01" value="0.2">
        </div>
        <div class="control-group">
            <h3>Sunlight</h3>
            <label for="sunlight-toggle"><span>Enable</span><input type="checkbox" id="sunlight-toggle" checked></label>
            <label for="sunlight-intensity">Intensity</label>
            <input type="range" id="sunlight-intensity" min="0" max="1000" step="1" value="50">
            <label for="sunlight-color">Color</label>
            <input type="color" id="sunlight-color" value="#ffeedd">
            <label for="sunlight-height">Height</label>
            <input type="range" id="sunlight-height" min="0" max="20" step="0.5" value="10">
        </div>
        <div class="control-group">
            <h3>Volumetric Light</h3>
            <label for="volumetric-toggle"><span>Enable</span><input type="checkbox" id="volumetric-toggle" checked></label>
            <label for="volumetric-intensity">Intensity</label>
            <input type="range" id="volumetric-intensity" min="0" max="50" step="0.1" value="15">
            <label for="volumetric-color">Color</label>
            <input type="color" id="volumetric-color" value="#ffffff">
        </div>
        <div class="control-group">
            <h3>Model Distortion</h3>
            <label for="wave-frequency">Max Wave Frequency</label>
            <input type="range" id="wave-frequency" min="0" max="20" step="0.1" value="4.0">
            <label for="wave-amplitude">Amplitude</label>
            <input type="range" id="wave-amplitude" min="0" max="2" step="0.05" value="1.0">
        </div>
        <div class="control-group">
            <h3>Glitch Effect</h3>
            <label for="glitch-intensity">Intensity</label>
            <input type="range" id="glitch-intensity" min="0" max="1" step="0.01" value="0.5">
            <label for="glitch-threshold">Threshold</label>
            <input type="range" id="glitch-threshold" min="0" max="1" step="0.01" value="0.8">
        </div>

        <div class="control-group">
            <h3>Music Waves</h3>
            <label for="music-waves-toggle"><span>Enable</span><input type="checkbox" id="music-waves-toggle" checked></label>
            <label for="music-waves-count">Wave Count</label>
            <input type="range" id="music-waves-count" min="1" max="20" step="1" value="3">
            <label for="music-waves-speed">Speed</label>
            <input type="range" id="music-waves-speed" min="0.1" max="100" step="0.1" value="0.8">
            <label for="music-waves-trail-length">Trail Length</label>
            <input type="range" id="music-waves-trail-length" min="20" max="300" step="5" value="40">
            <label for="music-waves-glow">Glow Intensity</label>
            <input type="range" id="music-waves-glow" min="0.1" max="100" step="0.1" value="1.5">
            <label for="music-waves-color">Wave Color</label>
            <input type="color" id="music-waves-color" value="#00ffff">
        </div>
        <div class="control-group">
            <h3>Projectile Impact</h3>
            <label for="projectile-toggle"><span>Enable</span><input type="checkbox" id="projectile-toggle" checked></label>
            <label for="projectile-speed">Speed</label>
            <input type="range" id="projectile-speed" min="0.1" max="2" step="0.1" value="0.8">
            <label for="projectile-force">Impact Force</label>
            <input type="range" id="projectile-force" min="0" max="5" step="0.1" value="1.5">
            <label for="projectile-radius">Impact Radius</label>
            <input type="range" id="projectile-radius" min="0.1" max="3" step="0.1" value="1.0">
            <label for="debris-density">Debris Density %</label>
            <input type="range" id="debris-density" min="1" max="100" step="1" value="50">
            <label for="projectile-heal">Heal Speed</label>
            <input type="range" id="projectile-heal" min="0.01" max="0.2" step="0.01" value="0.05">
            <label for="projectile-heal-color">Heal Color</label>
            <input type="color" id="projectile-heal-color" value="#00ffff">
        </div>
        <div class="control-group">
            <h3>Audio Player</h3>
            <div id="audio-controls" style="margin-bottom: 15px;">
                <audio id="audio" controls style="width: 100%; height: 40px;"></audio>
            </div>
            <div id="seeking-controls" style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <span id="current-time" style="font-size: 0.8em; color: #888;">0:00</span>
                    <span id="total-time" style="font-size: 0.8em; color: #888;">0:00</span>
                </div>
                <input type="range" id="audio-seek" min="0" max="100" step="0.1" value="0" style="width: 100%;">
                <div style="display: flex; gap: 5px; margin-top: 8px;">
                    <button id="seek-backward-10" style="flex: 1; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.8em;">-10s</button>
                    <button id="seek-backward-30" style="flex: 1; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.8em;">-30s</button>
                    <button id="seek-forward-30" style="flex: 1; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.8em;">+30s</button>
                    <button id="seek-forward-10" style="flex: 1; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.8em;">+10s</button>
                </div>
                <div style="display: flex; gap: 5px; margin-top: 5px;">
                    <button id="seek-to-start" style="flex: 1; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.8em;">Start</button>
                    <button id="pause-audio" style="flex: 1; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; font-size: 0.8em;">Pause</button>
                </div>
            </div>
            <label for="audio-volume">Volume</label>
            <input type="range" id="audio-volume" min="0" max="1" step="0.01" value="0.7" style="width: 100%;">
            <label for="audio-playback-rate">Playback Speed</label>
            <select id="audio-playback-rate" style="width: 100%; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                <option value="0.5">0.5x (Slow)</option>
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x (Normal)</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x (Fast)</option>
                <option value="2">2x (Very Fast)</option>
            </select>
            <button id="audio-loop" style="width: 100%; padding: 6px; margin-top: 8px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer;">Loop: Off</button>
        </div>
        <div class="control-group">
            <h3>Camera Control</h3>
            <div id="camera-status" style="text-align: center; font-size: 0.8em; color: #00ff00; margin-bottom: 10px;">Auto Mode Active</div>
            <label for="camera-mode"><span>Mode</span>
                <select id="camera-mode" style="width: 100%; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                    <option value="auto" selected>Auto (Audio Reactive)</option>
                    <option value="manual">Manual Control</option>
                    <option value="orbit">Orbit Mode</option>
                    <option value="static">Static Position</option>
                </select>
            </label>
            <label for="camera-sensitivity">Audio Sensitivity</label>
            <input type="range" id="camera-sensitivity" min="0" max="2" step="0.1" value="1.0" style="width: 100%;">
            <label for="camera-speed">Movement Speed</label>
            <input type="range" id="camera-speed" min="0.1" max="3" step="0.1" value="1.0" style="width: 100%;">
            <label for="camera-distance">Distance</label>
            <input type="range" id="camera-distance" min="3" max="15" step="0.5" value="8" style="width: 100%;">
            <div style="margin-top: 10px;">
                <button id="reset-camera" style="width: 100%; padding: 6px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer;">Reset Camera</button>
            </div>
        </div>
        <div class="control-group">
            <h3>Keyboard Shortcuts</h3>
            <div style="font-size: 0.8em; color: #ccc; line-height: 1.4; margin-bottom: 10px;">
                <div style="margin-bottom: 5px;"><strong>Space</strong> - Play/Pause Audio</div>
                <div style="margin-bottom: 5px;"><strong>R</strong> - Start/Stop Recording</div>
                <div style="margin-bottom: 5px;"><strong>M</strong> - Next Model</div>
                <div style="margin-bottom: 5px;"><strong>N</strong> - Next Audio Track</div>
                <div style="margin-bottom: 5px;"><strong>H</strong> - Toggle Menu</div>
                <div style="margin-bottom: 5px;"><strong>F</strong> - Fullscreen</div>
                <div style="margin-bottom: 5px;"><strong>Esc</strong> - Exit Fullscreen</div>
                <div style="margin-bottom: 5px;"><strong>1-4</strong> - Camera Modes</div>
                <div style="margin-bottom: 5px;"><strong>‚Üë‚Üì</strong> - Volume Up/Down</div>
                <div style="margin-bottom: 5px;"><strong>‚Üê‚Üí</strong> - Seek -10s/+10s</div>
            </div>
        </div>
        <div class="control-group">
            <h3>Video Recording</h3>
            <button id="record-button" style="width: 100%; padding: 8px; margin-bottom: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer;">Start Recording</button>
            <div id="recording-status" style="text-align: center; font-size: 0.9em; color: #888; margin-bottom: 10px;"></div>
            <div id="audio-status" style="text-align: center; font-size: 0.8em; color: #666; margin-bottom: 10px;"></div>
            <label for="video-quality">Quality</label>
            <select id="video-quality" style="width: 100%; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                <option value="high">High Quality</option>
                <option value="medium" selected>Medium Quality</option>
                <option value="low">Low Quality</option>
            </select>
            <label for="video-fps">FPS</label>
            <select id="video-fps" style="width: 100%; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 4px;">
                <option value="60">60 FPS</option>
                <option value="30" selected>30 FPS</option>
                <option value="24">24 FPS</option>
            </select>
        </div>
    </div>

    <div id="drop-zone">
        <p>Drop 3D Models (.glb/.gltf) & Audio Files (.mp3/.wav/.ogg)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';

        let scene, camera, renderer, controls, composer, bloomPass;
        let analyser, dataArray;
        let audioContext = null;
        let loadedModel = null, isAudioReady = false;
        let originalVertices = new Map();
        let time = 0;
        let smoothedBass = 0, smoothedMids = 0, smoothedTreble = 0, smoothedHighMids = 0;
        let ambientLight, bassLight, trebleLight, laser1, laser2, volumetricLight, sunlight;
        let glitchAmount = 0;
        
        // Multiple file management
        let loadedModels = [];
        let loadedAudioFiles = [];
        let currentModelIndex = 0;
        let currentAudioIndex = 0;
        
        let healingZones = [];
        let debrisParticles = new THREE.Group();
        let projectiles = new THREE.Group();
        let trails = new THREE.Group();
        let musicWavesGroup = new THREE.Group();
        let atmosphericParticles;
        let lastProjectileTime = 0;
        let lastSmoothedBass = 0;
        let modelBoundingBox = new THREE.Box3();
        
        // Video recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        
        // Camera control variables
        let cameraMode = 'auto';
        let cameraSensitivity = 1.0;
        let cameraSpeed = 1.0;
        let cameraDistance = 8;
        let cameraTarget = new THREE.Vector3(0, 1, 0);
        let cameraAutoRotation = 0;
        let cameraAutoHeight = 0;
        
        // Camera angle panel variables
        let cameraAnglePanelOpen = false;
        let cameraRenderers = {};
        let cameraScenes = {};
        let cameraCameras = {};
        let isDragging = false;
        let isResizing = false;
        let draggedElement = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let elementStartX = 0;
        let elementStartY = 0;
        let elementStartWidth = 0;
        let elementStartHeight = 0;
        
        // Code view panel variables
        let codeViewPanelOpen = false;
        let currentFunction = '';
        let functionCallCount = 0;
        let lastUpdateTime = 0;

        const dropZone = document.getElementById('drop-zone');
        const dropZoneText = dropZone.querySelector('p');
        const audioElement = document.getElementById('audio');

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                switch(e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        if (audioElement.paused) {
                            audioElement.play();
                        } else {
                            audioElement.pause();
                        }
                        break;
                        
                    case 'r':
                        e.preventDefault();
                        if (isRecording) {
                            stopRecording();
                        } else {
                            startRecording();
                        }
                        break;
                        
                    case 'm':
                        e.preventDefault();
                        if (loadedModels.length > 1) {
                            currentModelIndex = (currentModelIndex + 1) % loadedModels.length;
                            if (loadedModels[currentModelIndex].loaded) {
                                selectModel(currentModelIndex);
                            }
                        }
                        break;
                        
                    case 'n':
                        e.preventDefault();
                        if (loadedAudioFiles.length > 1) {
                            currentAudioIndex = (currentAudioIndex + 1) % loadedAudioFiles.length;
                            selectAudio(currentAudioIndex);
                        }
                        break;
                        
                    case 'h':
                        e.preventDefault();
                        const menuToggle = document.getElementById('menu-toggle');
                        const controlsPanel = document.getElementById('controls-panel');
                        menuToggle.classList.toggle('open');
                        controlsPanel.classList.toggle('open');
                        break;
                        
                    case 'f':
                        e.preventDefault();
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen();
                        }
                        break;
                        
                    case 'escape':
                        if (document.fullscreenElement) {
                            document.exitFullscreen();
                        }
                        break;
                        
                    case '1':
                        e.preventDefault();
                        document.getElementById('camera-mode').value = 'auto';
                        cameraMode = 'auto';
                        updateCameraMode();
                        break;
                        
                    case '2':
                        e.preventDefault();
                        document.getElementById('camera-mode').value = 'manual';
                        cameraMode = 'manual';
                        updateCameraMode();
                        break;
                        
                    case '3':
                        e.preventDefault();
                        document.getElementById('camera-mode').value = 'orbit';
                        cameraMode = 'orbit';
                        updateCameraMode();
                        break;
                        
                    case '4':
                        e.preventDefault();
                        document.getElementById('camera-mode').value = 'static';
                        cameraMode = 'static';
                        updateCameraMode();
                        break;
                        
                    case 'arrowup':
                        e.preventDefault();
                        const currentVolume = audioElement.volume;
                        audioElement.volume = Math.min(1, currentVolume + 0.1);
                        document.getElementById('audio-volume').value = audioElement.volume;
                        break;
                        
                    case 'arrowdown':
                        e.preventDefault();
                        const currentVol = audioElement.volume;
                        audioElement.volume = Math.max(0, currentVol - 0.1);
                        document.getElementById('audio-volume').value = audioElement.volume;
                        break;
                        
                    case 'arrowleft':
                        e.preventDefault();
                        audioElement.currentTime = Math.max(0, audioElement.currentTime - 10);
                        break;
                        
                    case 'arrowright':
                        e.preventDefault();
                        audioElement.currentTime = Math.min(audioElement.duration, audioElement.currentTime + 10);
                        break;
                }
            });
        }
        
        function setupFileUploads() {
            const modelUpload = document.getElementById('model-upload');
            const audioUpload = document.getElementById('audio-upload');
            
            modelUpload.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleModelFiles(e.target.files);
                }
            });
            
            audioUpload.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleAudioFiles(e.target.files);
                }
            });
        }
        
        function setupDragAndDrop() {
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) handleFiles(e.dataTransfer.files);
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.add(debrisParticles, projectiles, trails, musicWavesGroup);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0);
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.enableRotate = true;
            controls.enabled = false; // Start with auto mode disabled
            
            // Better touch support
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            // Set reasonable limits
            controls.minDistance = 2;
            controls.maxDistance = 20;
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;

            // Lighting Setup
            ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);
            
            // Sunlight - directional light for overall illumination
            sunlight = new THREE.DirectionalLight(0xffeedd, 0.5);
            sunlight.position.set(10, 10, 5);
            sunlight.castShadow = true;
            sunlight.shadow.mapSize.width = 2048;
            sunlight.shadow.mapSize.height = 2048;
            sunlight.shadow.camera.near = 0.5;
            sunlight.shadow.camera.far = 50;
            sunlight.shadow.camera.left = -10;
            sunlight.shadow.camera.right = 10;
            sunlight.shadow.camera.top = 10;
            sunlight.shadow.camera.bottom = -10;
            scene.add(sunlight);
            
            bassLight = new THREE.SpotLight(0xff0000, 0, 0, Math.PI / 4, 0.5, 2);
            trebleLight = new THREE.SpotLight(0x0000ff, 0, 0, Math.PI / 4, 0.5, 2);
            volumetricLight = new THREE.SpotLight(0xffffff, 0, 0, Math.PI / 3, 0.3, 2);
            scene.add(bassLight, bassLight.target, trebleLight, trebleLight.target, volumetricLight, volumetricLight.target);
            
            // Laser Beams
            const laserGeometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 32);
            const laserMaterial1 = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 });
            const laserMaterial2 = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
            laser1 = new THREE.Mesh(laserGeometry, laserMaterial1);
            laser2 = new THREE.Mesh(laserGeometry, laserMaterial2);
            laser1.position.set(-4, -5, -5);
            laser2.position.set(4, -5, -5);
            laser1.rotation.x = Math.PI / 2.5;
            laser2.rotation.x = Math.PI / 2.5;
            scene.add(laser1, laser2);

            // --- NEW: Reflective Floor ---
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMirror = new Reflector(floorGeometry, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0x777777
            });
            groundMirror.position.y = -2;
            groundMirror.rotateX(-Math.PI / 2);
            groundMirror.receiveShadow = true;
            scene.add(groundMirror);

            // --- NEW: Atmospheric Particles ---
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCnt = 5000;
            const posArray = new Float32Array(particlesCnt * 3);
            for(let i = 0; i < particlesCnt * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 20;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.015,
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            atmosphericParticles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(atmosphericParticles);

            // Post-processing
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize, false);
            setupUIControls();
            setupDragAndDrop();
            animate();
        }

        function setupAudioContext() {
            if (analyser) return; 
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audioElement);
            analyser = audioContext.createAnalyser();
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            analyser.fftSize = 512; 
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        function setupUIControls() {
            const menuToggle = document.getElementById('menu-toggle');
            const controlsPanel = document.getElementById('controls-panel');
            menuToggle.addEventListener('click', () => {
                menuToggle.classList.toggle('open');
                controlsPanel.classList.toggle('open');
            });

            document.getElementById('bass-color').addEventListener('input', (e) => bassLight.color.set(e.target.value));
            document.getElementById('treble-color').addEventListener('input', (e) => trebleLight.color.set(e.target.value));
            document.getElementById('volumetric-color').addEventListener('input', (e) => volumetricLight.color.set(e.target.value));
            document.getElementById('bloom-strength').addEventListener('input', (e) => bloomPass.strength = Number(e.target.value));
            document.getElementById('bloom-threshold').addEventListener('input', (e) => bloomPass.threshold = Number(e.target.value));
            
            // Sunlight controls
            document.getElementById('sunlight-color').addEventListener('input', (e) => sunlight.color.set(e.target.value));
            document.getElementById('sunlight-intensity').addEventListener('input', (e) => {
                const intensity = Number(e.target.value) / 100;
                sunlight.intensity = intensity;
            });
            document.getElementById('sunlight-height').addEventListener('input', (e) => {
                const height = Number(e.target.value);
                sunlight.position.y = height;
            });
            document.getElementById('sunlight-toggle').addEventListener('change', (e) => {
                sunlight.intensity = e.target.checked ? Number(document.getElementById('sunlight-intensity').value) / 100 : 0;
            });
            
            document.getElementById('projectile-heal-color').addEventListener('input', (e) => {
                if (loadedModel) {
                    loadedModel.traverse(child => {
                        if (child.isMesh && child.material.uniforms && child.material.uniforms.healingColor) {
                            child.material.uniforms.healingColor.value.set(e.target.value);
                        }
                    });
                }
            });
            
            // Music waves controls
            document.getElementById('music-waves-toggle').addEventListener('change', (e) => {
                if (!e.target.checked) {
                    musicWavesGroup.clear();
                }
            });
            

            

            
            // File upload controls
            setupFileUploads();
            
            // Video recording controls
            setupVideoRecording();
            
            // Audio controls
            setupAudioControls();
            
            // Camera controls
            setupCameraControls();
            
            // Initialize camera mode
            updateCameraMode();
            
            // Setup keyboard shortcuts
            setupKeyboardShortcuts();
            setupCameraAnglePanel();
            setupCodeViewPanel();
        }
        
        function setupVideoRecording() {
            const recordButton = document.getElementById('record-button');
            const recordingStatus = document.getElementById('recording-status');
            
            recordButton.addEventListener('click', () => {
                if (!isRecording) {
                    startRecording();
                } else {
                    stopRecording();
                }
            });
        }
        
        async function startRecording() {
            try {
                const canvas = renderer.domElement;
                const videoStream = canvas.captureStream(parseInt(document.getElementById('video-fps').value));
                
                // Get audio stream from the audio element
                let audioStream = null;
                const audioStatus = document.getElementById('audio-status');
                
                if (audioElement.src && !audioElement.paused && audioContext) {
                    try {
                        // Create a MediaStream destination from the existing audio context
                        const destination = audioContext.createMediaStreamDestination();
                        
                        // Connect the existing analyser to the destination for recording
                        analyser.connect(destination);
                        
                        // Get the audio stream
                        audioStream = destination.stream;
                        
                        audioStatus.textContent = '‚úÖ Audio will be recorded';
                        audioStatus.style.color = '#00ff00';
                    } catch (audioError) {
                        console.warn('Could not capture audio stream:', audioError);
                        audioStatus.textContent = '‚ö†Ô∏è Audio recording not available';
                        audioStatus.style.color = '#ffaa00';
                    }
                } else if (!audioContext) {
                    audioStatus.textContent = '‚ö†Ô∏è Audio context not initialized';
                    audioStatus.style.color = '#ffaa00';
                } else {
                    audioStatus.textContent = '‚ö†Ô∏è No audio playing - video only';
                    audioStatus.style.color = '#ffaa00';
                }
                
                // Combine video and audio streams
                const combinedStream = new MediaStream();
                
                // Add video tracks
                videoStream.getVideoTracks().forEach(track => {
                    combinedStream.addTrack(track);
                });
                
                // Add audio tracks if available
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => {
                        combinedStream.addTrack(track);
                    });
                }
                
                const quality = document.getElementById('video-quality').value;
                let mimeType = 'video/webm;codecs=vp9,opus';
                let bitrate = 5000000; // 5 Mbps default
                
                switch(quality) {
                    case 'high':
                        bitrate = 10000000; // 10 Mbps
                        mimeType = 'video/webm;codecs=vp9,opus';
                        break;
                    case 'medium':
                        bitrate = 5000000; // 5 Mbps
                        mimeType = 'video/webm;codecs=vp9,opus';
                        break;
                    case 'low':
                        bitrate = 2000000; // 2 Mbps
                        mimeType = 'video/webm;codecs=vp8,vorbis';
                        break;
                }
                
                const options = {
                    mimeType: mimeType,
                    videoBitsPerSecond: bitrate
                };
                
                mediaRecorder = new MediaRecorder(combinedStream, options);
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `3d-audio-visualizer-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                };
                
                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();
                
                document.getElementById('record-button').textContent = 'Stop Recording';
                document.getElementById('record-button').style.background = '#ff4444';
                
                updateRecordingStatus();
                
            } catch (error) {
                console.error('Failed to start recording:', error);
                alert('Failed to start recording. Please check browser permissions.');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                document.getElementById('record-button').textContent = 'Start Recording';
                document.getElementById('record-button').style.background = '#333';
                
                const recordingStatus = document.getElementById('recording-status');
                recordingStatus.textContent = 'Recording saved!';
                recordingStatus.style.color = '#00ff00';
                
                const audioStatus = document.getElementById('audio-status');
                audioStatus.textContent = '';
                
                setTimeout(() => {
                    recordingStatus.textContent = '';
                }, 3000);
            }
        }
        
        function updateRecordingStatus() {
            if (!isRecording) return;
            
            const recordingStatus = document.getElementById('recording-status');
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            recordingStatus.textContent = `Recording... ${minutes}:${seconds.toString().padStart(2, '0')}`;
            recordingStatus.style.color = '#ff4444';
            
            requestAnimationFrame(updateRecordingStatus);
        }
        
        function setupAudioControls() {
            const volumeSlider = document.getElementById('audio-volume');
            const playbackRateSelect = document.getElementById('audio-playback-rate');
            const loopButton = document.getElementById('audio-loop');
            const seekSlider = document.getElementById('audio-seek');
            const currentTimeSpan = document.getElementById('current-time');
            const totalTimeSpan = document.getElementById('total-time');
            
            // Volume control
            volumeSlider.addEventListener('input', (e) => {
                audioElement.volume = parseFloat(e.target.value);
            });
            
            // Playback rate control
            playbackRateSelect.addEventListener('change', (e) => {
                audioElement.playbackRate = parseFloat(e.target.value);
            });
            
            // Loop control
            loopButton.addEventListener('click', () => {
                audioElement.loop = !audioElement.loop;
                loopButton.textContent = audioElement.loop ? 'Loop: On' : 'Loop: Off';
                loopButton.style.background = audioElement.loop ? '#00aa00' : '#333';
            });
            
            // Seeking controls
            let isSeeking = false;
            
            // Update time display and seek slider
            function updateTimeDisplay() {
                if (audioElement.duration && !isNaN(audioElement.duration)) {
                    const currentTime = audioElement.currentTime;
                    const totalTime = audioElement.duration;
                    
                    // Update time displays
                    currentTimeSpan.textContent = formatTime(currentTime);
                    totalTimeSpan.textContent = formatTime(totalTime);
                    
                    // Update seek slider
                    if (!isSeeking) {
                        seekSlider.value = (currentTime / totalTime) * 100;
                    }
                }
            }
            
            // Format time as MM:SS
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Seek slider events
            seekSlider.addEventListener('mousedown', () => {
                isSeeking = true;
            });
            
            seekSlider.addEventListener('input', (e) => {
                if (audioElement.duration && !isNaN(audioElement.duration)) {
                    const seekTime = (parseFloat(e.target.value) / 100) * audioElement.duration;
                    audioElement.currentTime = seekTime;
                    currentTimeSpan.textContent = formatTime(seekTime);
                }
            });
            
            seekSlider.addEventListener('mouseup', () => {
                isSeeking = false;
            });
            
            // Quick seek buttons
            document.getElementById('seek-backward-10').addEventListener('click', () => {
                audioElement.currentTime = Math.max(0, audioElement.currentTime - 10);
            });
            
            document.getElementById('seek-backward-30').addEventListener('click', () => {
                audioElement.currentTime = Math.max(0, audioElement.currentTime - 30);
            });
            
            document.getElementById('seek-forward-30').addEventListener('click', () => {
                audioElement.currentTime = Math.min(audioElement.duration, audioElement.currentTime + 30);
            });
            
            document.getElementById('seek-forward-10').addEventListener('click', () => {
                audioElement.currentTime = Math.min(audioElement.duration, audioElement.currentTime + 10);
            });
            
            document.getElementById('seek-to-start').addEventListener('click', () => {
                audioElement.currentTime = 0;
            });
            
            document.getElementById('pause-audio').addEventListener('click', () => {
                if (audioElement.paused) {
                    audioElement.play();
                } else {
                    audioElement.pause();
                }
            });
            
            // Update time display periodically
            audioElement.addEventListener('timeupdate', updateTimeDisplay);
            audioElement.addEventListener('loadedmetadata', updateTimeDisplay);
            
            // Set initial volume
            audioElement.volume = 0.7;
        }
        
        function setupCameraControls() {
            const cameraModeSelect = document.getElementById('camera-mode');
            const cameraSensitivitySlider = document.getElementById('camera-sensitivity');
            const cameraSpeedSlider = document.getElementById('camera-speed');
            const cameraDistanceSlider = document.getElementById('camera-distance');
            const resetCameraButton = document.getElementById('reset-camera');
            
            // Camera mode control
            cameraModeSelect.addEventListener('change', (e) => {
                cameraMode = e.target.value;
                updateCameraMode();
            });
            
            // Camera sensitivity control
            cameraSensitivitySlider.addEventListener('input', (e) => {
                cameraSensitivity = parseFloat(e.target.value);
            });
            
            // Camera speed control
            cameraSpeedSlider.addEventListener('input', (e) => {
                cameraSpeed = parseFloat(e.target.value);
            });
            
            // Camera distance control
            cameraDistanceSlider.addEventListener('input', (e) => {
                cameraDistance = parseFloat(e.target.value);
                updateCameraPosition();
            });
            
            // Reset camera button
            resetCameraButton.addEventListener('click', () => {
                resetCamera();
            });
        }
        
        function updateCameraMode() {
            console.log('Updating camera mode to:', cameraMode); // Debug log
            
            const cameraStatus = document.getElementById('camera-status');
            
            switch(cameraMode) {
                case 'auto':
                    controls.enabled = false;
                    controls.autoRotate = false;
                    cameraStatus.textContent = 'Auto Mode Active (Mouse/Touch Disabled)';
                    cameraStatus.style.color = '#00ff00';
                    console.log('Auto mode: controls disabled');
                    break;
                case 'manual':
                    controls.enabled = true;
                    controls.autoRotate = false;
                    controls.enablePan = true;
                    controls.enableZoom = true;
                    controls.enableRotate = true;
                    cameraStatus.textContent = 'Manual Mode Active (Mouse/Touch Enabled)';
                    cameraStatus.style.color = '#ffff00';
                    console.log('Manual mode: controls enabled');
                    
                    // Reset camera to a good starting position for manual control
                    setTimeout(() => {
                        camera.position.set(0, 2, cameraDistance);
                        controls.target.set(0, 1, 0);
                        controls.update();
                    }, 100);
                    break;
                case 'orbit':
                    controls.enabled = true;
                    controls.autoRotate = true;
                    controls.autoRotateSpeed = 1.0;
                    controls.enablePan = true;
                    controls.enableZoom = true;
                    controls.enableRotate = true;
                    cameraStatus.textContent = 'Orbit Mode Active (Mouse/Touch Enabled)';
                    cameraStatus.style.color = '#ffff00';
                    console.log('Orbit mode: controls enabled with auto-rotate');
                    
                    // Reset camera to a good starting position for orbit control
                    setTimeout(() => {
                        camera.position.set(0, 2, cameraDistance);
                        controls.target.set(0, 1, 0);
                        controls.update();
                    }, 100);
                    break;
                case 'static':
                    controls.enabled = false;
                    controls.autoRotate = false;
                    resetCamera();
                    cameraStatus.textContent = 'Static Mode Active (Mouse/Touch Disabled)';
                    cameraStatus.style.color = '#ff4444';
                    console.log('Static mode: controls disabled');
                    break;
            }
            
            // Force controls update
            controls.update();
        }
        
        function updateCameraPosition() {
            if (cameraMode === 'static') {
                camera.position.set(0, 2, cameraDistance);
                camera.lookAt(cameraTarget);
            }
        }
        
        function resetCamera() {
            camera.position.set(0, 2, cameraDistance);
            camera.lookAt(cameraTarget);
            controls.target.copy(cameraTarget);
            controls.update();
        }

        function handleFiles(files) {
            const modelFiles = [];
            const audioFiles = [];
            
            for (const file of files) {
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.glb') || fileName.endsWith('.gltf')) {
                    modelFiles.push(file);
                } else if (fileName.endsWith('.mp3') || fileName.endsWith('.wav') || fileName.endsWith('.ogg')) {
                    audioFiles.push(file);
                }
            }
            
            if (modelFiles.length > 0) handleModelFiles(modelFiles);
            if (audioFiles.length > 0) handleAudioFiles(audioFiles);
        }
        
        function handleModelFiles(files) {
            for (const file of files) {
                addModelFile(file);
            }
        }
        
        function handleAudioFiles(files) {
            for (const file of files) {
                addAudioFile(file);
            }
        }

        function addModelFile(file) {
            const modelData = {
                file: file,
                name: file.name,
                url: URL.createObjectURL(file),
                loaded: false,
                scene: null
            };
            
            loadedModels.push(modelData);
            updateModelList();
            
            // Load the model
            loadModelFromData(modelData);
        }
        
        function addAudioFile(file) {
            const audioData = {
                file: file,
                name: file.name,
                url: URL.createObjectURL(file)
            };
            
            loadedAudioFiles.push(audioData);
            updateAudioList();
            
            // If this is the first audio file, load it automatically
            if (loadedAudioFiles.length === 1) {
                loadAudioFromData(audioData);
            }
        }
        
        function loadModelFromData(modelData) {
            const loader = new GLTFLoader();
            loader.load(modelData.url, (gltf) => {
                modelData.scene = gltf.scene;
                modelData.loaded = true;
                
                // If this is the first model, load it automatically
                if (loadedModels.length === 1) {
                    loadModel(modelData);
                }
            }, undefined, (error) => {
                console.error('Failed to load model:', modelData.name, error);
            });
        }
        
        function loadAudioFromData(audioData) {
            audioElement.src = audioData.url;
            audioElement.load();
            audioElement.play().catch(e => console.error("Autoplay blocked:", e));
            if (!analyser) setupAudioContext();
            isAudioReady = true;
            updateDropZoneStatus();
        }
        
        function loadModel(modelData) {
            if (loadedModel) scene.remove(loadedModel);
            loadedModel = modelData.scene.clone();
            
            const box = new THREE.Box3().setFromObject(loadedModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 5 / maxDim;
            
            loadedModel.scale.set(scale, scale, scale);
            loadedModel.position.sub(center.multiplyScalar(scale));
            
            modelBoundingBox.setFromObject(loadedModel); 
            
            loadedModel.traverse((child) => {
                if (child.isMesh) {
                    child.geometry.computeVertexNormals();
                    const alphaArray = new Float32Array(child.geometry.attributes.position.count).fill(1.0);
                    child.geometry.setAttribute('alpha', new THREE.BufferAttribute(alphaArray, 1));

                    // Enable shadow casting and receiving
                    child.castShadow = true;
                    child.receiveShadow = true;

                    child.material.onBeforeCompile = shader => {
                        shader.uniforms.healingColor = { value: new THREE.Color(document.getElementById('projectile-heal-color').value) };
                        shader.vertexShader = 'attribute float alpha;\nvarying float vAlpha;\n' + shader.vertexShader;
                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <begin_vertex>',
                            '#include <begin_vertex>\nvAlpha = alpha;'
                        );
                        shader.fragmentShader = 'varying float vAlpha;\nuniform vec3 healingColor;\n' + shader.fragmentShader;
                        shader.fragmentShader = shader.fragmentShader.replace(
                            /}\s*$/,
                            `   if (vAlpha < 1.0) {
                                    if (vAlpha <= 0.0) discard;
                                    gl_FragColor.a *= vAlpha;
                                    // Only show healing glow when alpha is between 0.1 and 0.9 (healing front)
                                    if (vAlpha > 0.1 && vAlpha < 0.9) {
                                        float edge = smoothstep(0.1, 0.3, vAlpha) - smoothstep(0.7, 0.9, vAlpha);
                                        gl_FragColor.rgb += healingColor * edge * 2.0;
                                    }
                                }
                            }`
                        );
                    };
                    child.material.transparent = true;
                    child.material.needsUpdate = true;

                    originalVertices.set(child.uuid, {
                        positions: child.geometry.attributes.position.array.slice(),
                        normals: child.geometry.attributes.normal.array.slice()
                    });
                }
            });
            scene.add(loadedModel);

            const modelCenter = new THREE.Vector3();
            box.getCenter(modelCenter);
            const modelSize = box.getSize(new THREE.Vector3());

            bassLight.position.set(modelCenter.x - modelSize.x * 1.5, modelCenter.y + modelSize.y, modelCenter.z);
            bassLight.target.position.copy(modelCenter);
            bassLight.distance = modelSize.x * 5;

            trebleLight.position.set(modelCenter.x + modelSize.x * 1.5, modelCenter.y + modelSize.y, modelCenter.z);
            trebleLight.target.position.copy(modelCenter);
            trebleLight.distance = modelSize.x * 5;

            volumetricLight.position.set(modelCenter.x, modelCenter.y + modelSize.y * 2, modelCenter.z + modelSize.z);
            volumetricLight.target.position.copy(modelCenter);
            volumetricLight.distance = modelSize.y * 5;

            updateDropZoneStatus();
        }

        function loadAudio(audioData) {
            audioElement.src = audioData.url;
            audioElement.load();
            audioElement.play().catch(e => console.error("Autoplay blocked:", e));
            if (!analyser) setupAudioContext();
            isAudioReady = true;
            updateDropZoneStatus();
        }
        
        function updateModelList() {
            const modelList = document.getElementById('model-list');
            modelList.innerHTML = '';
            
            if (loadedModels.length === 0) {
                modelList.innerHTML = '<div class="file-item" style="color: #888; font-style: italic;">No models loaded</div>';
                return;
            }
            
            loadedModels.forEach((modelData, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                if (index === currentModelIndex && modelData.loaded) {
                    fileItem.classList.add('active');
                }
                
                fileItem.innerHTML = `
                    <span class="file-name">${modelData.name}</span>
                    <button class="file-remove" onclick="removeModel(${index})">√ó</button>
                `;
                
                fileItem.addEventListener('click', () => {
                    if (modelData.loaded) {
                        selectModel(index);
                    }
                });
                
                modelList.appendChild(fileItem);
            });
        }
        
        function updateAudioList() {
            const audioList = document.getElementById('audio-list');
            audioList.innerHTML = '';
            
            if (loadedAudioFiles.length === 0) {
                audioList.innerHTML = '<div class="file-item" style="color: #888; font-style: italic;">No audio files loaded</div>';
                return;
            }
            
            loadedAudioFiles.forEach((audioData, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                if (index === currentAudioIndex) {
                    fileItem.classList.add('active');
                }
                
                fileItem.innerHTML = `
                    <span class="file-name">${audioData.name}</span>
                    <button class="file-remove" onclick="removeAudio(${index})">√ó</button>
                `;
                
                fileItem.addEventListener('click', () => {
                    selectAudio(index);
                });
                
                audioList.appendChild(fileItem);
            });
        }
        
        function selectModel(index) {
            if (index >= 0 && index < loadedModels.length && loadedModels[index].loaded) {
                currentModelIndex = index;
                loadModel(loadedModels[index]);
                updateModelList();
            }
        }
        
        function selectAudio(index) {
            if (index >= 0 && index < loadedAudioFiles.length) {
                currentAudioIndex = index;
                loadAudio(loadedAudioFiles[index]);
                updateAudioList();
            }
        }
        
        function removeModel(index) {
            if (index >= 0 && index < loadedModels.length) {
                const modelData = loadedModels[index];
                URL.revokeObjectURL(modelData.url);
                loadedModels.splice(index, 1);
                
                if (loadedModels.length === 0) {
                    if (loadedModel) {
                        scene.remove(loadedModel);
                        loadedModel = null;
                    }
                    currentModelIndex = 0;
                } else {
                    currentModelIndex = Math.min(currentModelIndex, loadedModels.length - 1);
                    if (loadedModels[currentModelIndex].loaded) {
                        loadModel(loadedModels[currentModelIndex]);
                    }
                }
                
                updateModelList();
                updateDropZoneStatus();
            }
        }
        
        function removeAudio(index) {
            if (index >= 0 && index < loadedAudioFiles.length) {
                const audioData = loadedAudioFiles[index];
                URL.revokeObjectURL(audioData.url);
                loadedAudioFiles.splice(index, 1);
                
                if (loadedAudioFiles.length === 0) {
                    audioElement.src = '';
                    isAudioReady = false;
                    currentAudioIndex = 0;
                } else {
                    currentAudioIndex = Math.min(currentAudioIndex, loadedAudioFiles.length - 1);
                    loadAudio(loadedAudioFiles[currentAudioIndex]);
                }
                
                updateAudioList();
                updateDropZoneStatus();
            }
        }
        
        function updateDropZoneStatus() {
            if (loadedModels.length > 0 && loadedAudioFiles.length > 0) {
                dropZone.classList.add('hidden');
            } else if (loadedModels.length > 0) {
                dropZoneText.textContent = 'Drop Audio Files (.mp3/.wav/.ogg)';
            } else if (loadedAudioFiles.length > 0) {
                dropZoneText.textContent = 'Drop 3D Models (.glb/.gltf)';
            } else {
                dropZoneText.textContent = 'Drop 3D Models (.glb/.gltf) & Audio Files (.mp3/.wav/.ogg)';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            controls.update();

            glitchAmount *= 0.9; 
            updateProjectilesAndHealing();
            updateMusicWaves();
            updateCameraViews();
            
            // Update code viewer with current function execution
            updateCodeViewer('animate', { time: time.toFixed(2) });
            
            if (atmosphericParticles) {
                atmosphericParticles.rotation.y += 0.0005;
            }

            // Camera movement based on mode
            if (cameraMode === 'auto') {
                // Audio-reactive camera movement
                const audioIntensity = (smoothedBass + smoothedMids + smoothedTreble) / 3;
                const baseRotation = time * 0.1 * cameraSpeed;
                const audioRotation = audioIntensity * cameraSensitivity * 0.5;
                const heightVariation = Math.sin(time * 0.3) * audioIntensity * cameraSensitivity * 2;
                
                camera.position.x = Math.sin(baseRotation + audioRotation) * cameraDistance;
                camera.position.z = Math.cos(baseRotation + audioRotation) * cameraDistance;
                camera.position.y = 2 + heightVariation;
                camera.lookAt(cameraTarget);
                
                // Update controls target to follow the camera
                controls.target.copy(cameraTarget);
            } else if (cameraMode === 'static') {
                // Static camera position
                camera.position.set(0, 2, cameraDistance);
                camera.lookAt(cameraTarget);
                controls.target.copy(cameraTarget);
            } else if (cameraMode === 'manual' || cameraMode === 'orbit') {
                // In manual/orbit modes, let OrbitControls handle everything
                // Don't interfere with user input - controls will update camera position
                // Just ensure controls are updated
                controls.update();
            }


            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                const freqCount = analyser.frequencyBinCount;
                
                const bassSliceEnd = Math.floor(freqCount * 0.1);
                const midsSliceStart = bassSliceEnd;
                const midsSliceEnd = Math.floor(freqCount * 0.4);
                const highMidsSliceStart = midsSliceEnd;
                const highMidsSliceEnd = Math.floor(freqCount * 0.7);
                const trebleSliceStart = highMidsSliceEnd;

                const bassSlice = dataArray.slice(0, bassSliceEnd);
                const midsSlice = dataArray.slice(midsSliceStart, midsSliceEnd);
                const highMidsSlice = dataArray.slice(highMidsSliceStart, highMidsSliceEnd);
                const trebleSlice = dataArray.slice(trebleSliceStart, freqCount);

                const bassAvg = bassSlice.reduce((a, b) => a + b, 0) / (bassSlice.length || 1);
                const midsAvg = midsSlice.reduce((a, b) => a + b, 0) / (midsSlice.length || 1);
                const highMidsAvg = highMidsSlice.reduce((a, b) => a + b, 0) / (highMidsSlice.length || 1);
                const trebleAvg = trebleSlice.reduce((a, b) => a + b, 0) / (trebleSlice.length || 1);
                
                const normalizedHighMids = highMidsAvg / 255.0;
                const normalizedBass = bassAvg / 255.0;
                
                const glitchThreshold = Number(document.getElementById('glitch-threshold').value);
                if (normalizedHighMids > smoothedHighMids + (1 - glitchThreshold) * 0.5) {
                    glitchAmount = 1.0;
                }

                if (document.getElementById('projectile-toggle').checked && 
                    normalizedBass > lastSmoothedBass + 0.15 && 
                    now - lastProjectileTime > 200) { 
                    fireProjectile();
                    lastProjectileTime = now;
                }

                lastSmoothedBass = smoothedBass;
                smoothedBass = THREE.MathUtils.lerp(smoothedBass, normalizedBass, 0.1);
                smoothedMids = THREE.MathUtils.lerp(smoothedMids, midsAvg / 255.0, 0.1);
                smoothedHighMids = THREE.MathUtils.lerp(smoothedHighMids, normalizedHighMids, 0.2);
                smoothedTreble = THREE.MathUtils.lerp(smoothedTreble, trebleAvg / 255.0, 0.1);
                
                // Update code viewer with audio analysis
                updateCodeViewer('analyzeAudio', { 
                    bass: normalizedBass.toFixed(3), 
                    mid: (midsAvg / 255.0).toFixed(3), 
                    treble: (trebleAvg / 255.0).toFixed(3) 
                });
                
                time += (0.002 + smoothedMids * 0.03);

                if (loadedModel) updateModelVertices();
                updateLights();
            }

            composer.render();
        }

        function updateLights() {
            // Update code viewer
            updateCodeViewer('updateLights');
            
            ambientLight.intensity = smoothedMids * 0.5;
            bassLight.intensity = smoothedBass * document.getElementById('bass-intensity').value;
            trebleLight.intensity = smoothedTreble * document.getElementById('treble-intensity').value;
            
            const isVolumetricOn = document.getElementById('volumetric-toggle').checked;
            volumetricLight.intensity = isVolumetricOn ? (smoothedMids * 0.5 + 0.4) * document.getElementById('volumetric-intensity').value : 0;
            
            // Update sunlight based on controls
            const isSunlightOn = document.getElementById('sunlight-toggle').checked;
            if (isSunlightOn) {
                const baseIntensity = Number(document.getElementById('sunlight-intensity').value) / 100;
                // Add subtle audio reactivity to sunlight
                const audioReactivity = (smoothedBass + smoothedMids) * 0.1;
                sunlight.intensity = baseIntensity + audioReactivity;
            } else {
                sunlight.intensity = 0;
            }
            
            const laserOpacity = document.getElementById('laser-opacity').value;
            laser1.material.opacity = smoothedBass * laserOpacity;
            laser1.material.color.setHSL(time % 1, 1, 0.5);
            laser1.rotation.z = time * 0.2;
            laser2.material.opacity = smoothedTreble * laserOpacity;
            laser2.material.color.setHSL((time + 0.5) % 1, 1, 0.5);
            laser2.rotation.z = time * -0.2;
        }
        
        function fireProjectile() {
            if (modelBoundingBox.isEmpty()) return;

            const speed = Number(document.getElementById('projectile-speed').value);
            const projectileGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const projectileMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const projectile = new THREE.Mesh(projectileGeo, projectileMat);

            const startPos = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 10,
                camera.position.z + 5 + Math.random() * 5
            );
            projectile.position.copy(startPos);
            
            const targetPos = new THREE.Vector3().random().subScalar(0.5).multiply(modelBoundingBox.getSize(new THREE.Vector3())).add(modelBoundingBox.getCenter(new THREE.Vector3()));
            projectile.userData.velocity = targetPos.clone().sub(startPos).normalize().multiplyScalar(speed);
            
            projectiles.add(projectile);
        }

        // --- Helper: Perlin Noise for organic healing front ---
        // Simplex/Perlin noise for organic effect (use a simple hash-based noise for now)
        function simpleNoise(x) {
            return Math.sin(x * 12.9898) * 43758.5453 % 1;
        }

        // --- MODIFIED: triggerImpact ---
        function triggerImpact(impactPoint, impactVector) {
            const force = Number(document.getElementById('projectile-force').value);
            const radius = Number(document.getElementById('projectile-radius').value);
            const debrisDensity = Number(document.getElementById('debris-density').value) / 100.0;

            loadedModel.traverse(child => {
                if (child.isMesh && child.geometry.attributes.position) {
                    const alphaAttribute = child.geometry.attributes.alpha;
                    const positionAttribute = child.geometry.attributes.position;
                    const normalAttribute = child.geometry.attributes.normal;
                    const vCount = positionAttribute.count;

                    const debrisPositions = [];
                    const healingVertexData = [];
                    const debrisNormals = [];
                    let maxRadius = 0;

                    for (let i = 0; i < vCount; i++) {
                        const pos = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                        const dist = pos.distanceTo(impactPoint);
                        if (dist < radius) {
                            if (Math.random() < debrisDensity) {
                                // Fracture: displace vertex outward along normal with randomness
                                const normal = new THREE.Vector3().fromBufferAttribute(normalAttribute, i);
                                const origPos = pos.clone();
                                const fractureStrength = 0.3 + Math.random() * 0.8;
                                const displaced = pos.clone().add(normal.clone().multiplyScalar(fractureStrength * (1 - dist / radius)));
                                // Add some random direction for more organic look
                                displaced.x += (Math.random() - 0.5) * 0.15;
                                displaced.y += (Math.random() - 0.5) * 0.15;
                                displaced.z += (Math.random() - 0.5) * 0.15;
                                positionAttribute.setXYZ(i, displaced.x, displaced.y, displaced.z);
                                alphaAttribute.setX(i, 0);
                                debrisPositions.push(pos.x, pos.y, pos.z);
                                debrisNormals.push(normal.x, normal.y, normal.z);
                                healingVertexData.push({
                                    index: i,
                                    distance: dist,
                                    orig: origPos,
                                    fractured: displaced
                                });
                                if (dist > maxRadius) maxRadius = dist;
                            }
                        }
                    }

                    if (debrisPositions.length > 0) {
                        alphaAttribute.needsUpdate = true;
                        positionAttribute.needsUpdate = true;

                        // Create multiple debris particle systems with different colors
                        const debrisColors = [0xff4444, 0x884444, 0x444444, 0x666666];
                        const debrisSizes = [0.03, 0.05, 0.07, 0.04];
                        
                        for (let colorIndex = 0; colorIndex < debrisColors.length; colorIndex++) {
                            const debrisGeometry = new THREE.BufferGeometry();
                            const colorPositions = [];
                            const colorNormals = [];
                            
                            // Distribute particles across different color groups
                            for (let i = colorIndex; i < debrisPositions.length; i += debrisColors.length) {
                                colorPositions.push(debrisPositions[i], debrisPositions[i+1], debrisPositions[i+2]);
                                colorNormals.push(debrisNormals[i], debrisNormals[i+1], debrisNormals[i+2]);
                            }
                            
                            if (colorPositions.length > 0) {
                                debrisGeometry.setAttribute('position', new THREE.Float32BufferAttribute(colorPositions, 3));
                                const debrisMaterial = new THREE.PointsMaterial({ 
                                    color: debrisColors[colorIndex], 
                                    size: debrisSizes[colorIndex], 
                                    transparent: true,
                                    opacity: 0.8
                                });
                                const debris = new THREE.Points(debrisGeometry, debrisMaterial);
                                debris.userData.velocities = [];
                                for (let i = 0; i < colorPositions.length / 3; i++) {
                                    const normal = new THREE.Vector3(colorNormals[i*3], colorNormals[i*3+1], colorNormals[i*3+2]);
                                    
                                    // Calculate impact direction (projectile velocity)
                                    const impactDir = impactVector.clone().normalize();
                                    
                                    // Mix normal direction with impact direction for more realistic debris flow
                                    const debrisDir = new THREE.Vector3()
                                        .addVectors(
                                            normal.clone().multiplyScalar(0.3), // Some normal direction
                                            impactDir.clone().multiplyScalar(0.7) // Mostly impact direction
                                        )
                                        .normalize();
                                    
                                    // Add some randomness to the direction
                                    debrisDir.x += (Math.random() - 0.5) * 0.4;
                                    debrisDir.y += (Math.random() - 0.5) * 0.4;
                                    debrisDir.z += (Math.random() - 0.5) * 0.4;
                                    debrisDir.normalize();
                                    
                                    // Calculate velocity based on impact force and distance from impact point
                                    const velocity = debrisDir.multiplyScalar(force * (Math.random() * 1.2 + 0.8));
                                    debris.userData.velocities.push(velocity);
                                }
                                debris.userData.life = 2.0 + Math.random() * 0.5;
                                debrisParticles.add(debris);
                            }
                        }

                        healingZones.push({
                            mesh: child,
                            vertexData: healingVertexData,
                            center: impactPoint,
                            maxRadius: maxRadius,
                            healProgress: 0,
                            startHealingTime: performance.now() + 500 
                        });
                    }
                }
            });
        }


        
        function updateProjectilesAndHealing() {
            const now = performance.now();
            const healSpeed = Number(document.getElementById('projectile-heal').value);
            const raycaster = new THREE.Raycaster();
            
            // Update code viewer
            updateCodeViewer('updateProjectilesAndHealing');

            // Update projectiles and trails
            for (let i = projectiles.children.length - 1; i >= 0; i--) {
                const p = projectiles.children[i];
                p.position.add(p.userData.velocity);

                const trailGeo = new THREE.SphereGeometry(0.05, 4, 4);
                const trailMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
                const trailPart = new THREE.Mesh(trailGeo, trailMat);
                trailPart.position.copy(p.position);
                trailPart.userData.life = 0.5;
                trails.add(trailPart);

                if (p.position.length() > 30) {
                    projectiles.remove(p);
                    continue;
                }

                if (loadedModel) {
                    raycaster.set(p.position, p.userData.velocity.clone().normalize());
                    const intersects = raycaster.intersectObject(loadedModel, true);

                    if (intersects.length > 0 && intersects[0].distance < 1.0) {
                        triggerImpact(intersects[0].point, p.userData.velocity);
                        projectiles.remove(p);
                    }
                }
            }
            
            // Update trails
            for (let i = trails.children.length - 1; i >= 0; i--) {
                const t = trails.children[i];
                t.userData.life -= 1/60;
                t.material.opacity = THREE.MathUtils.clamp(t.userData.life * 2, 0, 1);
                if (t.userData.life <= 0) {
                    trails.remove(t);
                    t.geometry.dispose();
                    t.material.dispose();
                }
            }

            // Update debris
            for (let i = debrisParticles.children.length - 1; i >= 0; i--) {
                const debris = debrisParticles.children[i];
                debris.userData.life -= 1/60;
                
                const positions = debris.geometry.attributes.position;
                for (let j = 0; j < positions.count; j++) {
                    const velocity = debris.userData.velocities[j];
                    
                    // Update position with velocity
                    positions.setXYZ(j, 
                        positions.getX(j) + velocity.x * 0.02, 
                        positions.getY(j) + velocity.y * 0.02, 
                        positions.getZ(j) + velocity.z * 0.02
                    );
                    
                    // Apply air resistance (slow down over time)
                    velocity.multiplyScalar(0.92);
                    
                    // Add gravity effect
                    velocity.y -= 0.002;
                    
                    // Add some turbulence for more realistic movement
                    velocity.x += (Math.random() - 0.5) * 0.001;
                    velocity.z += (Math.random() - 0.5) * 0.001;
                }
                positions.needsUpdate = true;
                
                // Progressive fade out - start fading earlier for smoother dissolution
                const lifeRatio = debris.userData.life / 2.5;
                const fadeStart = 0.8; // Start fading at 80% life
                let opacity = 0.8;
                
                if (lifeRatio < fadeStart) {
                    opacity = THREE.MathUtils.smoothstep(0, fadeStart, lifeRatio) * 0.8;
                }
                
                debris.material.opacity = THREE.MathUtils.clamp(opacity, 0, 0.8);
                
                // Shrink particles as they fade
                debris.material.size = THREE.MathUtils.lerp(0.01, debris.material.size, lifeRatio);
                
                if (debris.userData.life <= 0) {
                    debrisParticles.remove(debris);
                    debris.geometry.dispose();
                    debris.material.dispose();
                }
            }

            // Update healing zones
            for (let i = healingZones.length - 1; i >= 0; i--) {
                const zone = healingZones[i];
                if (now > zone.startHealingTime) {
                    zone.healProgress += healSpeed * 0.15;
                    const alphaAttribute = zone.mesh.geometry.attributes.alpha;
                    const positionAttribute = zone.mesh.geometry.attributes.position;
                    
                    // Improved healing front calculation
                    const healRadius = zone.maxRadius * Math.min(zone.healProgress, 1.0);
                    const falloff = zone.maxRadius * 0.3;

                    for (let j = 0; j < zone.vertexData.length; j++) {
                        const data = zone.vertexData[j];
                        const dist = data.distance;
                        
                        // Better organic healing front with smoother noise
                        const noise = simpleNoise(dist * 2 + now * 0.0003) * 0.3;
                        const healFront = healRadius + noise;
                        
                        // Calculate healing factor (0 to 1)
                        let healFactor = 0;
                        if (dist <= healFront - falloff) {
                            healFactor = 1.0; // Fully healed
                        } else if (dist <= healFront) {
                            healFactor = THREE.MathUtils.smoothstep(healFront, healFront - falloff, dist);
                        }
                        
                        // Ensure healFactor is clamped between 0 and 1
                        healFactor = THREE.MathUtils.clamp(healFactor, 0, 1);
                        
                        // Set alpha
                        alphaAttribute.setX(data.index, healFactor);
                        
                        // Interpolate position from fractured to original
                        positionAttribute.setXYZ(
                            data.index,
                            THREE.MathUtils.lerp(data.fractured.x, data.orig.x, healFactor),
                            THREE.MathUtils.lerp(data.fractured.y, data.orig.y, healFactor),
                            THREE.MathUtils.lerp(data.fractured.z, data.orig.z, healFactor)
                        );
                    }
                    
                    alphaAttribute.needsUpdate = true;
                    positionAttribute.needsUpdate = true;

                    // Remove healing zone when fully healed
                    if (zone.healProgress >= 1.2) {
                        // Ensure all vertices are fully restored
                        for (let j = 0; j < zone.vertexData.length; j++) {
                            const data = zone.vertexData[j];
                            alphaAttribute.setX(data.index, 1.0);
                            positionAttribute.setXYZ(
                                data.index,
                                data.orig.x,
                                data.orig.y,
                                data.orig.z
                            );
                        }
                        alphaAttribute.needsUpdate = true;
                        positionAttribute.needsUpdate = true;
                        healingZones.splice(i, 1);
                    }
                }
            }
        }

        function updateModelVertices() {
            // Update code viewer
            updateCodeViewer('updateModelVertices');
            
            loadedModel.traverse((child) => {
                if (child.isMesh && originalVertices.has(child.uuid)) {
                    const geom = child.geometry;
                    const posAttr = geom.attributes.position;
                    const origData = originalVertices.get(child.uuid);
                    const origPos = origData.positions;
                    const normals = origData.normals;
                    const vCount = posAttr.count;
                    
                    const maxWaveFreq = Number(document.getElementById('wave-frequency').value);
                    const maxAmp = Number(document.getElementById('wave-amplitude').value);
                    const glitchIntensity = Number(document.getElementById('glitch-intensity').value);

                    // Get detailed frequency data for regional reaction
                    let freqData = null;
                    if (analyser && dataArray) {
                        freqData = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(freqData);
                    }

                    // Calculate model bounds for regional mapping
                    const modelBounds = new THREE.Box3().setFromObject(child);
                    const modelSize = modelBounds.getSize(new THREE.Vector3());
                    const modelCenter = modelBounds.getCenter(new THREE.Vector3());

                    for (let i = 0; i < vCount; i++) {
                        const ox = origPos[i * 3], oy = origPos[i * 3 + 1], oz = origPos[i * 3 + 2];
                        const nx = normals[i * 3], ny = normals[i * 3 + 1], nz = normals[i * 3 + 2];
                        
                        // Calculate regional position (0-1) relative to model bounds
                        const regionalX = (ox - modelCenter.x + modelSize.x/2) / modelSize.x;
                        const regionalY = (oy - modelCenter.y + modelSize.y/2) / modelSize.y;
                        const regionalZ = (oz - modelCenter.z + modelSize.z/2) / modelSize.z;
                        
                        // Create unique regional frequency mapping
                        let regionalBass = 0, regionalMid = 0, regionalTreble = 0, regionalSub = 0;
                        
                        if (freqData) {
                            // Map different regions to different frequency ranges
                            const regionHash = Math.abs(regionalX * 100 + regionalY * 200 + regionalZ * 300);
                            
                            // Sub-bass (very low frequencies) - affects bottom regions
                            const subIndex = Math.floor((regionalY * 0.3 + regionalZ * 0.7) * 8);
                            regionalSub = freqData[subIndex] / 255.0;
                            
                            // Bass - affects different regions based on X position
                            const bassIndex = Math.floor((regionalX * 0.4 + regionalY * 0.6) * 12) + 8;
                            regionalBass = freqData[bassIndex] / 255.0;
                            
                            // Mid - affects center regions more
                            const midIndex = Math.floor((regionalX * 0.5 + regionalY * 0.3 + regionalZ * 0.2) * 20) + 20;
                            regionalMid = freqData[midIndex] / 255.0;
                            
                            // Treble - affects outer regions and details
                            const trebleIndex = Math.floor((regionalX * 0.6 + regionalY * 0.2 + regionalZ * 0.2) * 30) + 40;
                            regionalTreble = freqData[trebleIndex] / 255.0;
                            
                            // Add regional variation based on position
                            const regionalVariation = simpleNoise(regionalX * 10 + regionalY * 15 + regionalZ * 20) * 0.3;
                            regionalBass *= (1 + regionalVariation);
                            regionalMid *= (1 + regionalVariation * 0.5);
                            regionalTreble *= (1 + regionalVariation * 0.8);
                        } else {
                            // Fallback with regional variation
                            regionalSub = smoothedBass * (0.5 + regionalY * 0.5);
                            regionalBass = smoothedBass * (0.7 + regionalX * 0.3);
                            regionalMid = smoothedMids * (0.6 + regionalZ * 0.4);
                            regionalTreble = smoothedTreble * (0.8 + regionalX * 0.2);
                        }
                        
                        // Create organic wave patterns with regional variation
                        const timeScale = time * 0.5; // Slower time for more organic movement
                        
                        // Sub-bass waves (deep, slow movement)
                        const subWave1 = Math.sin(oy * (0.2 + regionalSub * 1.5) + timeScale * 0.3);
                        const subWave2 = Math.cos(ox * (0.15 + regionalSub * 1.2) + timeScale * 0.4);
                        
                        // Bass waves (stronger, more directional)
                        const bassWave1 = Math.sin(ox * (0.4 + regionalBass * 2.5) + timeScale * 0.8);
                        const bassWave2 = Math.cos(oy * (0.3 + regionalBass * 2.0) + timeScale * 1.1);
                        const bassWave3 = Math.sin(oz * (0.35 + regionalBass * 2.2) + timeScale * 0.9);
                        
                        // Mid waves (complex patterns)
                        const midWave1 = Math.sin(ox * (0.8 + regionalMid * 3.5) + timeScale * 1.5);
                        const midWave2 = Math.cos(oy * (0.6 + regionalMid * 3.0) + timeScale * 1.8);
                        const midWave3 = Math.sin(oz * (0.7 + regionalMid * 3.2) + timeScale * 1.2);
                        const midWave4 = Math.cos(ox * (0.9 + regionalMid * 2.8) + timeScale * 1.6);
                        
                        // Treble waves (detailed, fast movement)
                        const trebleWave1 = Math.sin(ox * (1.5 + regionalTreble * 4.5) + timeScale * 2.5);
                        const trebleWave2 = Math.cos(oy * (1.2 + regionalTreble * 4.0) + timeScale * 2.8);
                        const trebleWave3 = Math.sin(oz * (1.3 + regionalTreble * 4.2) + timeScale * 2.2);
                        
                        // Combine waves with regional weighting
                        const subDisplacement = (subWave1 + subWave2) * regionalSub * 0.5;
                        const bassDisplacement = (bassWave1 + bassWave2 + bassWave3) * regionalBass * 0.33;
                        const midDisplacement = (midWave1 + midWave2 + midWave3 + midWave4) * regionalMid * 0.25;
                        const trebleDisplacement = (trebleWave1 + trebleWave2 + trebleWave3) * regionalTreble * 0.33;
                        
                        // Add organic noise with regional variation
                        const noiseScale = 0.15;
                        const noise1 = simpleNoise(ox * 3 + timeScale * 0.3) * noiseScale * regionalBass;
                        const noise2 = simpleNoise(oy * 3 + timeScale * 0.5) * noiseScale * regionalMid;
                        const noise3 = simpleNoise(oz * 3 + timeScale * 0.4) * noiseScale * regionalTreble;
                        
                        // Create regional intensity variations
                        const regionalIntensity = simpleNoise(regionalX * 5 + regionalY * 7 + regionalZ * 11) * 0.4 + 0.6;
                        
                        // Calculate total displacement with regional scaling
                        const totalDisplacement = (
                            subDisplacement * 0.8 + 
                            bassDisplacement * 1.2 + 
                            midDisplacement * 1.0 + 
                            trebleDisplacement * 0.8 + 
                            noise1 + noise2 + noise3
                        ) * maxAmp * regionalIntensity;
                        
                        // Remove uniform pulsing - replace with regional breathing
                        const regionalBreathing = simpleNoise(regionalX * 2 + regionalY * 3 + timeScale * 0.2) * 0.1;
                        const breathingEffect = regionalBreathing * (regionalBass + regionalMid) * 0.3;
                        
                        // Glitch effect with regional variation
                        let gx = 0, gy = 0, gz = 0;
                        if (glitchAmount > 0.01) {
                            const glitchNoise = simpleNoise(i + timeScale * 8);
                            const regionalGlitch = simpleNoise(regionalX * 10 + regionalY * 15 + regionalZ * 20);
                            gx = (glitchNoise - 0.5) * glitchIntensity * glitchAmount * regionalGlitch;
                            gy = simpleNoise(i + 100 + timeScale * 8) * glitchIntensity * glitchAmount * regionalGlitch;
                            gz = simpleNoise(i + 200 + timeScale * 8) * glitchIntensity * glitchAmount * regionalGlitch;
                        }
                        
                        // Apply displacement with regional variation
                        const finalDisplacement = totalDisplacement + breathingEffect;
                        posAttr.setXYZ(i, 
                            ox + nx * finalDisplacement + gx, 
                            oy + ny * finalDisplacement + gy, 
                            oz + nz * finalDisplacement + gz
                        );
                    }
                    posAttr.needsUpdate = true;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Make functions globally available for onclick handlers
        window.removeModel = removeModel;
        window.removeAudio = removeAudio;
        
        // Music Waves Functions - SURFACE CRAWLING WAVES
        function createMusicWave() {
            if (!loadedModel) return;
            
            const waveCount = Number(document.getElementById('music-waves-count').value);
            const currentWaves = musicWavesGroup.children.length;
            
            if (currentWaves >= waveCount) return;
            
            const modelCenter = modelBoundingBox.getCenter(new THREE.Vector3());
            const modelSize = modelBoundingBox.getSize(new THREE.Vector3());
            const radius = Math.max(modelSize.x, modelSize.y, modelSize.z) * 1.2;
            
            const trailLength = Number(document.getElementById('music-waves-trail-length').value);
            const waveColor = new THREE.Color(document.getElementById('music-waves-color').value);
            
            // Create wave group
            const waveGroup = new THREE.Group();
            
            // Create surface-crawling wave
            const trailGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(trailLength * 3);
            const colors = new Float32Array(trailLength * 3);
            
            const angle = (currentWaves / waveCount) * Math.PI * 2;
            
            // Initialize trail with surface pattern
            for (let i = 0; i < trailLength; i++) {
                const progress = i / trailLength;
                const waveAngle = angle + progress * 0.6;
                const waveRadius = radius * (0.8 + progress * 0.4);
                const surfaceHeight = Math.sin(progress * Math.PI * 4) * 0.2;
                
                positions[i * 3] = modelCenter.x + Math.cos(waveAngle) * waveRadius;
                positions[i * 3 + 1] = modelCenter.y + surfaceHeight;
                positions[i * 3 + 2] = modelCenter.z + Math.sin(waveAngle) * waveRadius;
                
                const alpha = 1 - progress;
                colors[i * 3] = waveColor.r * alpha;
                colors[i * 3 + 1] = waveColor.g * alpha;
                colors[i * 3 + 2] = waveColor.b * alpha;
            }
            
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const trailMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            waveGroup.add(trail);
            
            // Create enhanced glowing head
            const headGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({
                color: waveColor,
                transparent: true,
                opacity: 1.0
            });
            
            const head = new THREE.Mesh(headGeometry, headMaterial);
            waveGroup.add(head);
            
            // Create surface interaction points
            const interactionGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const interactionMaterial = new THREE.MeshBasicMaterial({
                color: waveColor,
                transparent: true,
                opacity: 0.6
            });
            
            const interactionPoints = [];
            for (let i = 0; i < 5; i++) {
                const point = new THREE.Mesh(interactionGeometry, interactionMaterial.clone());
                waveGroup.add(point);
                interactionPoints.push(point);
            }
            
            waveGroup.userData = {
                trail: trail,
                head: head,
                interactionPoints: interactionPoints,
                trailLength: trailLength,
                speed: Number(document.getElementById('music-waves-speed').value),
                angle: angle,
                radius: radius,
                modelCenter: modelCenter.clone(),
                time: Math.random() * 15,
                wavePhase: Math.random() * Math.PI * 2,
                surfaceOffset: Math.random() * Math.PI * 2,
                crawlDirection: new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize()
            };
            
            musicWavesGroup.add(waveGroup);
        }
        
        function updateMusicWaves() {
            const isEnabled = document.getElementById('music-waves-toggle').checked;
            if (!isEnabled) {
                musicWavesGroup.clear();
                return;
            }
            
            // Update code viewer
            updateCodeViewer('updateMusicWaves');
            
            createMusicWave();
            
            musicWavesGroup.children.forEach((waveGroup) => {
                const userData = waveGroup.userData;
                const trail = userData.trail;
                const head = userData.head;
                const interactionPoints = userData.interactionPoints;
                const trailLength = userData.trailLength;
                const speed = userData.speed;
                const radius = userData.radius;
                const modelCenter = userData.modelCenter;
                
                userData.time += 0.025 * speed;
                userData.wavePhase += 0.1;
                userData.surfaceOffset += 0.05;
                
                // Get audio frequency data for reactive waves
                let bassIntensity = 0, midIntensity = 0, trebleIntensity = 0;
                if (analyser && dataArray) {
                    const freqCount = analyser.frequencyBinCount;
                    const bassSlice = dataArray.slice(0, Math.floor(freqCount * 0.1));
                    const midSlice = dataArray.slice(Math.floor(freqCount * 0.1), Math.floor(freqCount * 0.4));
                    const trebleSlice = dataArray.slice(Math.floor(freqCount * 0.7), freqCount);
                    
                    bassIntensity = bassSlice.reduce((a, b) => a + b, 0) / (bassSlice.length || 1) / 255;
                    midIntensity = midSlice.reduce((a, b) => a + b, 0) / (midSlice.length || 1) / 255;
                    trebleIntensity = trebleSlice.reduce((a, b) => a + b, 0) / (trebleSlice.length || 1) / 255;
                }
                
                const baseAngle = userData.angle + userData.time;
                
                // Get current trail positions and colors
                const positions = trail.geometry.attributes.position.array;
                const colors = trail.geometry.attributes.color.array;
                
                // Shift trail positions backward to create movement
                for (let i = trailLength - 1; i > 0; i--) {
                    positions[i * 3] = positions[(i - 1) * 3];
                    positions[i * 3 + 1] = positions[(i - 1) * 3 + 1];
                    positions[i * 3 + 2] = positions[(i - 1) * 3 + 2];
                }
                
                // Calculate surface-crawling position with model interaction
                const bassWave = Math.sin(userData.time * 2) * bassIntensity * 1.2;
                const midWave = Math.sin(userData.time * 4) * midIntensity * 0.8;
                const trebleWave = Math.sin(userData.time * 8) * trebleIntensity * 0.6;
                
                const waveOffset = bassWave + midWave + trebleWave;
                const surfaceRadius = radius * (0.7 + bassIntensity * 0.6);
                const surfaceHeight = Math.sin(userData.time * 3 + userData.surfaceOffset) * 0.3 + midIntensity * 0.4;
                
                // Create surface-crawling motion
                const crawlX = Math.cos(baseAngle + waveOffset) * surfaceRadius;
                const crawlZ = Math.sin(baseAngle + waveOffset) * surfaceRadius;
                const crawlY = surfaceHeight + trebleIntensity * 0.3;
                
                const newX = modelCenter.x + crawlX;
                const newY = modelCenter.y + crawlY;
                const newZ = modelCenter.z + crawlZ;
                
                // Set new head position
                positions[0] = newX;
                positions[1] = newY;
                positions[2] = newZ;
                
                // Update head position
                head.position.set(newX, newY, newZ);
                
                // Update interaction points along the trail
                interactionPoints.forEach((point, index) => {
                    const pointProgress = (index + 1) / (interactionPoints.length + 1);
                    const pointIndex = Math.floor(pointProgress * trailLength);
                    
                    if (pointIndex < trailLength) {
                        const pointX = positions[pointIndex * 3];
                        const pointY = positions[pointIndex * 3 + 1];
                        const pointZ = positions[pointIndex * 3 + 2];
                        
                        point.position.set(pointX, pointY, pointZ);
                        
                        // Make interaction points pulse with audio
                        const pointIntensity = bassIntensity * (1 - pointProgress) + midIntensity * pointProgress;
                        const pointScale = 0.05 + pointIntensity * 0.1;
                        point.scale.setScalar(pointScale);
                        point.material.opacity = 0.6 + pointIntensity * 0.4;
                    }
                });
                
                // Update trail colors with enhanced surface crawling effect
                const waveColor = new THREE.Color(document.getElementById('music-waves-color').value);
                const glowIntensity = Number(document.getElementById('music-waves-glow').value);
                
                for (let i = 0; i < trailLength; i++) {
                    const progress = i / trailLength;
                    const timeOffset = userData.time + progress * 3;
                    
                    // Create surface-crawling intensity pattern
                    const surfacePattern = Math.sin(progress * Math.PI * 6 + timeOffset * 2) * 0.3;
                    const bassPattern = Math.sin(progress * Math.PI * 4 + timeOffset * 1.5) * bassIntensity * 0.6;
                    const midPattern = Math.sin(progress * Math.PI * 8 + timeOffset * 3) * midIntensity * 0.5;
                    const treblePattern = Math.sin(progress * Math.PI * 12 + timeOffset * 6) * trebleIntensity * 0.4;
                    
                    const waveIntensity = 0.5 + surfacePattern + bassPattern + midPattern + treblePattern;
                    const alpha = (1 - progress) * waveIntensity;
                    const audioBoost = (bassIntensity + midIntensity + trebleIntensity) * glowIntensity * (1 - progress) * 0.6;
                    
                    colors[i * 3] = waveColor.r * (alpha + audioBoost);
                    colors[i * 3 + 1] = waveColor.g * (alpha + audioBoost);
                    colors[i * 3 + 2] = waveColor.b * (alpha + audioBoost);
                }
                
                // Force geometry updates
                trail.geometry.attributes.position.needsUpdate = true;
                trail.geometry.attributes.color.needsUpdate = true;
                
                // Update head with enhanced audio reactivity
                const totalIntensity = (bassIntensity + midIntensity + trebleIntensity) / 3;
                const headScale = 0.12 + totalIntensity * 0.5;
                head.scale.setScalar(headScale);
                head.material.color.copy(waveColor);
                head.material.opacity = 1.0 + totalIntensity * 0.4;
                
                // Add surface crawling effect to head
                const crawlEffect = Math.sin(userData.time * 5) * 0.02;
                head.position.y += crawlEffect;
            });
        }
        
        // Camera Angle Panel Functions
        function setupCameraAnglePanel() {
            const toggle = document.getElementById('camera-angle-toggle');
            const panel = document.getElementById('camera-angle-panel');
            
            toggle.addEventListener('click', () => {
                cameraAnglePanelOpen = !cameraAnglePanelOpen;
                toggle.classList.toggle('active', cameraAnglePanelOpen);
                panel.classList.toggle('open', cameraAnglePanelOpen);
                
                if (cameraAnglePanelOpen) {
                    initializeCameraViews();
                    setupViewDragging();
                }
            });
        }
        
        // Code View Panel Functions
        function setupCodeViewPanel() {
            const toggle = document.getElementById('code-view-toggle');
            const panel = document.getElementById('code-view-panel');
            
            toggle.addEventListener('click', () => {
                codeViewPanelOpen = !codeViewPanelOpen;
                toggle.classList.toggle('active', codeViewPanelOpen);
                panel.classList.toggle('open', codeViewPanelOpen);
                
                if (codeViewPanelOpen) {
                    setupCodeViewDragging();
                }
            });
        }
        
        function setupCodeViewDragging() {
            const panel = document.getElementById('code-view-panel');
            const header = panel.querySelector('.code-view-header');
            const resizeHandle = panel.querySelector('.code-view-resize-handle');
            
            // Setup dragging via header
            header.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                draggedElement = panel;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                elementStartX = parseInt(panel.style.left) || panel.offsetLeft;
                elementStartY = parseInt(panel.style.top) || panel.offsetTop;
                panel.style.zIndex = '1003';
            });
            
            // Setup resizing via resize handle
            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isResizing = true;
                draggedElement = panel;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                elementStartWidth = panel.offsetWidth;
                elementStartHeight = panel.offsetHeight;
                panel.style.zIndex = '1003';
            });
        }
        

        
        function updateCodeViewer(functionName, details = '') {
            if (!codeViewPanelOpen) return;
            
            const now = Date.now();
            if (now - lastUpdateTime < 100) return; // Throttle updates
            lastUpdateTime = now;
            
            const content = document.getElementById('code-view-content');
            const timestamp = new Date().toLocaleTimeString();
            
            // Create new code line
            const codeLine = document.createElement('div');
            codeLine.className = 'code-view-line active';
            
            let codeText = '';
            switch(functionName) {
                case 'updateMusicWaves':
                    codeText = `updateMusicWaves() { // Audio-reactive wave motion`;
                    break;
                case 'analyzeAudio':
                    codeText = `analyzeAudio() { // Frequency analysis: bass=${details.bass}, mid=${details.mid}, treble=${details.treble}`;
                    break;
                case 'updateCamera':
                    codeText = `updateCamera() { // Audio-reactive camera movement`;
                    break;
                case 'updateAtmosphericParticles':
                    codeText = `updateAtmosphericParticles() { // Particle system update`;
                    break;
                case 'updateProjectilesAndHealing':
                    codeText = `updateProjectilesAndHealing() { // Projectile physics & healing simulation`;
                    break;
                case 'updateModelVertices':
                    codeText = `updateModelVertices() { // Wave distortion effect`;
                    break;
                case 'updateLights':
                    codeText = `updateLights() { // Dynamic lighting update`;
                    break;
                case 'updateModelDistortion':
                    codeText = `updateModelDistortion() { // Wave distortion effect`;
                    break;
                case 'updateGlitchEffect':
                    codeText = `updateGlitchEffect() { // Glitch shader update`;
                    break;
                case 'animate':
                    codeText = `animate() { // Main render loop: time=${details.time}`;
                    break;
                default:
                    codeText = `${functionName}() { // Function execution}`;
            }
            
            codeLine.textContent = `[${timestamp}] ${codeText}`;
            
            // Add to content
            content.appendChild(codeLine);
            
            // Keep only last 15 lines (no scroll, so fewer lines for better visibility)
            while (content.children.length > 15) {
                content.removeChild(content.firstChild);
            }
            
            // Add fade effect to older lines
            const lines = content.children;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const age = lines.length - i;
                const opacity = Math.max(0.3, 1 - (age * 0.05));
                line.style.opacity = opacity;
                
                // Add subtle animation for new lines
                if (age === 1) {
                    line.style.animation = 'codeLineAppear 0.5s ease-out';
                }
            }
        }
        
        function setupViewDragging() {
            const views = document.querySelectorAll('.camera-view');
            
            views.forEach(view => {
                const header = view.querySelector('.camera-view-header');
                const resizeHandle = view.querySelector('.camera-view-resize-handle');
                
                // Setup dragging via header
                header.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isDragging = true;
                    draggedElement = view;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    elementStartX = parseInt(view.style.left) || view.offsetLeft;
                    elementStartY = parseInt(view.style.top) || view.offsetTop;
                    view.style.zIndex = '1003';
                });
                
                // Setup resizing via resize handle
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isResizing = true;
                    draggedElement = view;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    elementStartWidth = view.offsetWidth;
                    elementStartHeight = view.offsetHeight;
                    view.style.zIndex = '1003';
                });
                
                // Setup resizing observer
                const resizeObserver = new ResizeObserver(() => {
                    const viewType = view.getAttribute('data-view');
                    const renderer = cameraRenderers[viewType];
                    const camera = cameraCameras[viewType];
                    
                    if (renderer && camera) {
                        const rect = view.getBoundingClientRect();
                        renderer.setSize(rect.width, rect.height);
                        camera.aspect = rect.width / rect.height;
                        camera.updateProjectionMatrix();
                    }
                });
                
                resizeObserver.observe(view);
            });
            
            // Global mouse move handler
            document.addEventListener('mousemove', (e) => {
                if (isDragging && draggedElement) {
                    e.preventDefault();
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    draggedElement.style.left = (elementStartX + deltaX) + 'px';
                    draggedElement.style.top = (elementStartY + deltaY) + 'px';
                } else if (isResizing && draggedElement) {
                    e.preventDefault();
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    const newWidth = Math.max(120, elementStartWidth + deltaX);
                    const newHeight = Math.max(80, elementStartHeight + deltaY);
                    draggedElement.style.width = newWidth + 'px';
                    draggedElement.style.height = newHeight + 'px';
                }
            });
            
            // Global mouse up handler
            document.addEventListener('mouseup', () => {
                if ((isDragging || isResizing) && draggedElement) {
                    isDragging = false;
                    isResizing = false;
                    draggedElement.style.zIndex = '1001';
                    draggedElement = null;
                }
            });
        }
        
        function initializeCameraViews() {
            const viewTypes = ['top', 'front', 'perspective'];
            
            viewTypes.forEach(viewType => {
                if (!cameraRenderers[viewType]) {
                    const canvas = document.getElementById(`camera-${viewType}`);
                    const view = canvas.closest('.camera-view');
                    const rect = view.getBoundingClientRect();
                    
                    const renderer = new THREE.WebGLRenderer({ 
                        canvas: canvas, 
                        antialias: true,
                        alpha: true 
                    });
                    renderer.setSize(rect.width, rect.height);
                    renderer.setClearColor(0x000000, 0.8);
                    
                    const camera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x000000);
                    
                    // Position cameras based on view type
                    switch(viewType) {
                        case 'top':
                            camera.position.set(0, 15, 0);
                            camera.lookAt(0, 0, 0);
                            break;
                        case 'front':
                            camera.position.set(0, 0, 15);
                            camera.lookAt(0, 0, 0);
                            break;
                        case 'perspective':
                            camera.position.set(8, 8, 8);
                            camera.lookAt(0, 0, 0);
                            break;
                    }
                    
                    cameraRenderers[viewType] = renderer;
                    cameraCameras[viewType] = camera;
                    cameraScenes[viewType] = scene;
                }
            });
        }
        
        function updateCameraViews() {
            if (!cameraAnglePanelOpen) return;
            
            const viewTypes = ['top', 'front', 'perspective'];
            
            viewTypes.forEach(viewType => {
                const renderer = cameraRenderers[viewType];
                const camera = cameraCameras[viewType];
                const scene = cameraScenes[viewType];
                
                if (renderer && camera && scene) {
                    // Clear scene
                    scene.clear();
                    
                    // Clone main scene elements
                    if (loadedModel) {
                        const modelClone = loadedModel.clone();
                        scene.add(modelClone);
                    }
                    
                    // Add lights
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                    directionalLight.position.set(10, 10, 5);
                    scene.add(ambientLight, directionalLight);
                    
                    // Add music waves if enabled
                    if (document.getElementById('music-waves-toggle').checked && musicWavesGroup.children.length > 0) {
                        const wavesClone = musicWavesGroup.clone();
                        scene.add(wavesClone);
                    }
                    
                    // Add other scene elements
                    if (atmosphericParticles) {
                        const particlesClone = atmosphericParticles.clone();
                        scene.add(particlesClone);
                    }
                    
                    // Render the view
                    renderer.render(scene, camera);
                }
            });
        }
        
        // --- Start Everything ---
        init();
    </script>
</body>
</html>
